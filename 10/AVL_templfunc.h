#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

using namespace std;

//тип показателя баланса:
typedef short int balance;

//простейший элемент AVL-дерева:
template<class T>
struct Tree
{
	T key;//ключ
	Tree *left;//указатель на левое поддерево
	Tree *right;//указатель на правое поддерево

	balance BAL;/*значение баланса:
				"0" - левое и правое поддерево совпадают(по высоте)
				+1 - перевес в правом поддереве.
				"-1" - в левом.
				*/
};

/*
функция поиска для вставки задаваемого элемента в нужное место дерева:
ins - добавляемый элемент;
root - корень дерева;
high - показатель изменения высоты дерева на разных этапах.
*/
template<class T>
void SearchAndInsert(T ins, Tree<T>** root, bool &high)
{
	Tree<T> *change1, *change2;//для поворта (обмена) ссылок при балансировке.

	//если дерево пустое:
	if (*root == NULL)
	{
		*root = new Tree<T>;//выделяем память для созд. корня
		(*root)->key = ins;//инициализируем корень дерева
		(*root)->left = NULL;//слева элементов нет
		(*root)->right = NULL;//справа элементов нет
		(*root)->BAL = 0;//баланс уравновешенный
		high = true;//изменение высоты дерева
	}
	/*после того как корень существует*/

	//если добавляемый элемент меньше корня:
	else if ((*root)->key > ins)
	{
		//производим рекурсию для левой ветви корня:
		SearchAndInsert(ins, &((*root)->left), high);

		//если высота изменялась: 
		if (high == true)
		{
			/*
			определяем баланс у данного корня,
			при необходимости делаем балансировку:
			*/
			switch ((*root)->BAL)
			{
			case 1://балансировка не требуется:
			{
				(*root)->BAL = 0;//баланс уравновешен
				high = false;//поддерево в целом не выросло
				break;
			}
			//баланс уравновешенный:
			case 0:
			{
				(*root)->BAL = -1;//поддерево выросло допустимо для AVL-дерева
				break;
			}
			case -1://выполняется балансировка(!)
			{
				//записываем левый узел корня в переменную обмена:
				change1 = (*root)->left;

				//если наблюдается перевес в левом поддереве:
				if (change1->BAL == -1)//однократный левый поворот (обмен):
				{
					(*root)->left = change1->right;//левый узел присваивает свой правый
					change1->right = *root;//данный правый узел присваивает корень
					(*root)->BAL = 0;//балансировка произведена успешно
					*root = change1;//корень изменился для сохранения балансировки
				}
				else//иначе нужно произвести двойной левый, а затем правый поворот:
				{
					change2 = change1->right;//change2 - правая ветвь левого узла корня (change1)

					change1->right = change2->left;//в change2 записываем левый узел этой ветви
					change2->left = change1;//в данный левый узел записываем левый узел корня 
					(*root)->left = change2->right;//в левый узел корня записываем правый узел элемента change2
					change2->right = *root;//правый узел элемента change2 присвоил значение корня

					/*
					если балансировка у правой ветви левого
					узла корня перевешена в левую сторону:
					*/
					if (change2->BAL == -1)
						(*root)->BAL = 1;//у корня перевес становится на правую ветвь
					else (*root)->BAL = 0;//иначе баланс у корня уравновешен

					/*
			        если балансировка у правой ветви левого
					узла корня перевешена в правую сторону:
					*/
					if (change2->BAL == 1)
						change1->BAL = -1;//левый узел корня перевешен в левую часть
					else change1->BAL = 0;//иначе баланс у данного узла - уравновешен

					*root = change2;//появился новый корень для сохранения балансировки
				}
				(*root)->BAL = 0;//баланс дерева уравновешен
				high = false;//поддерево в целом не выросло
				break;
			}
			}
		}
	}
	//иначе, если добавляемый элемент больше корня:
	else if ((*root)->key < ins)
	{
		//производим рекурсию для правой ветви корня:
		SearchAndInsert(ins, &((*root)->right), high);

		//если высота подверглась изменению:
		if (high == true)
		{
			/*
			определяем баланс у данного корня,
			при необходимости делаем балансировку:
			*/
			switch ((*root)->BAL)
			{
			case -1://балансировка не требуется:
			{
				(*root)->BAL = 0;//поддерево в целом не выросло
				high = false;//=> высота тоже не выросла
				break;
			}
			case 0://баланс уравновешенный:
			{
				(*root)->BAL = 1;//поддерево выросло допустимо для AVL-дерева
				break;
			}
			case 1://требуется балансировка:
			{
				//записываем правый узел корня в переменную обмена:
				change1 = (*root)->right;

				if (change1->BAL == 1)//однократный правый поворот:
				{
					(*root)->right = change1->left;//в правую ветвь дерева записываем левый узел правого узла change1
					change1->left = *root;//в данный левый узел записываем корень
					(*root)->BAL = 0;//балансировка произведена успешно
					*root = change1;//корень изменился для сохранения балансировки
				}
				else//иначе двукратный правый + правый поворот:
				{
					change2 = change1->left;//change2 - правая ветвь левого узла корня (change1)
					change1->left = change2->right;//в change2 записываем правый узел этой ветви
					change2->right = change1;//в данный правый узел записываем правый узел корня

					(*root)->right = change2->left;//в правый узел корня записываем левый узел элемента change2
					change2->left = *root;//левый узел элемента change2 присвоил значение корня

					//если правая ветвь левого узла корня - перевешена в право:
					if (change2->BAL == 1)
						(*root)->BAL = -1;//корень перевешен в лево
					else (*root)->BAL = 0;//иначе корень уравновешен

										  //если правая ветвь левого узла корня - перевешена в лево:
					if (change2->BAL == -1)
						change1->BAL = 1;//правый узел корня перевешен в право	
					else change1->BAL = 0;//иначе правый узел корня уравновешен

					*root = change2;//появился новый корень для сохранения балансировки
				}
				(*root)->BAL = 0;//баланс дерева в целом уравновешен
				high = false;//поддерево в целом не выросло
				break;
			}
			}
		}
	}
}

template<class T>
/*
функция для балансировки (при необходимости) левой части дерева:
root - корень дерева;
high - показатель изменения высоты дерева на разных этапах.
*/
void BalanceL(Tree<T> **root, bool &high)
{
	if (*root == NULL)
		return;

	Tree<T> *change1, *change2;//для поворта (обмена) ссылок

	balance b1, b2;//вспомогательные переменные баланса

	/*
	определяем баланс у данного корня,
	при необходимости делаем балансировку:
	*/
	switch ((*root)->BAL)
	{
	case -1://балансировка не требуется:
	{
		(*root)->BAL = 0;//поддерево в целом не выросло
		break;
	}
	case 0://баланс уравновешенный:
	{
		(*root)->BAL = 1;//поддерево выросло допустимо для AVL-дерева
		high = false;//высота подверглась изменению
		break;
	}
	case 1://требуется балансировка:
	{
		//записываем правый узел корня в переменную обмена:
		change1 = (*root)->right;
		b1 = change1->BAL;//баланс этой переменной записываем в вспомогательную b1

		if (b1 >= 0)//однократный правый поворот
		{
			(*root)->right = change1->left;//в правую ветвь дерева записываем левый узел правого узла change1
			change1->left = *root;//в данный левый узел записываем корень

			//правый узел корня - уравновешен:
			if (b1 == 0)
			{
				(*root)->BAL = 1;//корень пе//корень изменился для сохранения балансировкиревешен в правую часть
				change1->BAL = -1;//правый узел корня перевешен в левую часть
				high = false;//высота не подверглась изменению
			}
			else
			{
				//баланс дерева уравновешен:
				(*root)->BAL = 0;
				change1->BAL = 0;
			}

			*root = change1;//корень изменился для сохранения балансировки
		}
		else//иначе двукратный правый + правый поворот:
		{
			change2 = change1->left;//change2 - правая ветвь левого узла корня (change1)
			b2 = change2->BAL;//баланс этой переменной записываем в вспомогательную b2
			change1->left = change2->right;//в change2 записываем правый узел этой ветви
			change2->right = change1;//в данный правый узел записываем правый узел корня

			(*root)->right = change2->left;//в правый узел корня записываем левый узел элемента change2
			change2->left = *root;//левый узел элемента change2 присвоил значение корня

			//если правая ветвь левого узла корня - перевешена в право:
			if (b2 == 1)
			{
				(*root)->BAL = -1;//корень перевешен в лево
			}
			else (*root)->BAL = 0;//иначе корень уравновешен

			//если правая ветвь левого узла корня - перевешена в лево:
			if (b2 == -1)
			{
				change1->BAL = 1;//правый узел корня перевешен в право
			}
			else change1->BAL = 0;//иначе этот узел уравновешен

			*root = change2;//корень изменился для сохранения балансировки
			change2->BAL = 0;//баланс уравновешен
		}
		break;
	}
	}
}

template<class T>
/*
функция для балансировки (при необходимости) правой части дерева:
root - корень дерева;
high - показатель изменения высоты дерева на разных этапах.
*/
void BalanceR(Tree<T> **root, bool &high)
{
	if (*root == NULL)
		return;

	Tree<T> *change1, *change2;//для поворта (обмена) ссылок

	balance b1, b2;//вспомогательные переменные баланса

	/*
	определяем баланс у данного корня,
	при необходимости делаем балансировку:
	*/
	switch ((*root)->BAL)
	{
	case 1://балансировка не требуется:
	{
		(*root)->BAL = 0;//баланс уравновешен
		break;
	}
	case 0://баланс уравновешенный:
	{
		(*root)->BAL = -1;//поддерево выросло допустимо для AVL-дерева
		high = false;
		break;
	}
	case -1://выполняется балансировка(!)
	{
		//записываем левый узел корня в переменную обмена:
		change1 = (*root)->left;
		b1 = change1->BAL;//записываем в вспомогательную переменную баланс левой ветви корня

		if (b1 <= 0)//однократный левый поворот:
		{
			(*root)->left = change1->right;//левый узел присваивает свой правый
			change1->right = *root;//в правый узел правого узла корня записывается значение корня

		    //если баланс у левой ветви корня - уравновешен:
			if (b1 == 0)
			{
				(*root)->BAL = -1;//баланс корня перевешен в лево
				change1->BAL = 1;//левый узел корня перевешен в право
				high = false;//высота не подверглась изменению
			}
			else//иначе:
			{
				//корень уравновешен:
				(*root)->BAL = 0;
				change1->BAL = 0;
			}

			*root = change1;//корень дерева изменяется для сохранения баланса дерева
		}
		else//двойной левый, затем правый поворот:
		{
			change2 = change1->right;//change2 - правая ветвь левого узла корня (change1)
			b2 = change2->BAL;//в вспомогательную переменную записываем баланс change2
			change1->right = change2->left;//правая ветвь левого узла корня присваивает левый узел change2
			change2->left = change1;//левый узел change2 присваивает левый узел корня
			(*root)->left = change2->right;//левый узел корня присваивает правый узел change2
			change2->right = *root;//правый узел change2 присваивает корень

			//если баланс change2 перевешен в лево:
			if (b2 == -1)
			{
				(*root)->BAL = 1;//баланс корня перевешен в право
			}
			else (*root)->BAL = 0;//иначе баланс корня уравновешен

			//если баланс change2 перевешен в право:
			if (b2 == 1)
			{
				change1->BAL = -1;//левый узел корня перевешен в лево
			}
			else change1->BAL = 0;//иначе этот узел уравновешен

			*root = change2;//корень изменяется для сохранения балансировки
			change2->BAL = 0;//баланс change2 - уравновешен
		}
		break;
	}
	}
}

template<class T>
//функция необходимая для удаления узла:
void HelpForDelete(Tree<T> **del, Tree<T> **helper, bool &high)
{
	if (*del == NULL)
		return;

	//если справа от удаляемого элемента ничего нет:
	if ((*del)->right != NULL)
	{
		//производим рекурсию для этого элемента:
		HelpForDelete(&((*del)->right), helper, high);

		//если высота подверглась изменению:
		if (high == true)
		{
			//выполняем балансировку, учитывая удаляемый элемент:
			BalanceR(del, high);
		}
	}
	else//иначе:
	{
		//записываем в вспомогательный элемент удаляемый:
		(*helper)->key = (*del)->key;

		//запоминаем указатель на удаляемый элемент:
		*helper = *del;

		//производим сдвиг в левый узел (от удаляемого):
		*del = (*del)->left;
		high = true;//высота изменилась
	}
}

template<class T>
//функция для удаления узла:
void Delete(T del_el, Tree<T> **root, bool &high)
{
	if (*root == NULL)
		return;

	//вспомогательный элемент для удаления:
	Tree<T> *helper = new Tree<T>;

	//если удаляемый элемент меньше корня дерева:
	if ((*root)->key > del_el)
	{
		//левый узел корня не конечный:
		if ((*root)->left != NULL)
		{
			//удаление с обращением к левому элементу от корня:
			Delete(del_el, &((*root)->left), high);

			//если высота подверглась изменению:
			if (high == true)
			{
				//требуется балансировка:
				BalanceL(root, high);
			}
		}
	}
	//если удаляемый элемент больше корневого:
	else if ((*root)->key < del_el)
	{
		//справа от корня пусто:
		if ((*root)->right != NULL)
		{
			//удаление с обращением к правому элементу от корня:
			Delete(del_el, &((*root)->right), high);

			//если высота изменилась:
			if (high == true)
			{
				//требуется балансировка:
				BalanceR(root, high);
			}
		}
	}
	else//в противном случае:
	{
		helper = *root;//помечаем корень

		//справа от корня пусто:
		if (helper->right == NULL)
		{
			//тогда корень смещается в левый узел:
			*root = helper->left;
			high = true;//высота изменилась
		}
		//слева от корня пусто:
		else if (helper->left == NULL)
		{
			//корень смещается в правый узел:
			*root = helper->right;
			high = true;//высота изменилась
		}
		else//иначе:
		{
			//если слева от корня есть элемент:
			if (helper->left != NULL)
			{
				//нужна вспомогательная функция для удаления элемента:
				HelpForDelete(&(helper->left), &helper, high);

				//если высота изменилась:
				if (high == true)
				{
					//требуется балансировка:
					BalanceL(&(*root), high);
				}
			}
		}
	}
}

template<class T>
//обход дерева - вывод:
void PrintTree(Tree<T> *root, int level)
{
	if (root != NULL)//если существует хотя бы корень:
	{
		PrintTree(root->left, level + 1);//вывод правого поддерева

		//для наглядности разделяем элементы пробелами:
		for (int i = 0; i < level; i++)
		{
			cout << "     ";
		}

		cout << root->key << endl;//вывод корня поддерева
		PrintTree(root->right, level + 1);//вывод левого поддерева
	}
	else return;//если нечего выводить - завершаем работу!
}